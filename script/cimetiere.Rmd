---
title: "cimetiere"
author: "B. Maranget"
date: "12/06/2023"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

identification tombes du cimetière

Sous Qgis, on crée les polygones des sépultures et un chemin qui permet de les numéroter.

on extrait les sommets du chemin afin de pouvoir récupérer les allées dont on garde le sens.

on intersecte le chemin et les sépultures afin de récupérer les pts sépultures.

puis on replace les sépultures sur les allées et on calcule la distance à partir de chaque point zéro de l'allée.

La dernière opération (intersection pt sépultures et allée) ne fonctionne pas sous Qgis


```{r}
library(sf)
library(mapsf)
library(rgdal)
```


# Chemin data


```{r, eval = T}
# on reprend variable HOME en fonction PC
rep <- Sys.getenv("HOME")
st_layers("../data/cimetiere.gpkg")
chemin <- "D:/03_SIG/03_03_Data/08_VOIRIE/cimetiere.gpkg"
```


```{r}
allee <- st_read("../data/cimetiere.gpkg", "lgAllee")
sep <- st_read("../data/cimetiere.gpkg", "ptSepulture")
ptAllee  <- st_read("../data/cimetiere.gpkg", "ptAllee")
chemin <- st_read("../data/cimetiere.gpkg", "chemin")
requiem <- st_read("../data/cimetiere.gpkg", "requiem")# le dessin des sépultures
```


# Prétraitement 


TO DO trouver comment extraire les sommets sous R

st_reverse points devient ligne
st_node ajoute des noeuds aux intersections
... tout simplement st_cast

```{r}
mf_map(chemin)
chemin$num <- rownames(chemin)
mf_label(chemin, var = "num")
```



choix du chemin 


```{r}
chemin <- chemin [5,]
```



```{r}
pt <- st_cast(chemin, "POINT")
mf_init(chemin)
mf_map(requiem, add = T, col = "green")
mf_map(chemin, add = T)
mf_map(pt, add = T)
pt$id <- rownames(pt)
#mf_label(pt, var = "id", halo = T)
```


repérage des lignes allée

On voit qu'il faut joindre les pts 2 à 2

```{r}
fin <- length(pt$id)/2
allee <- rep(LETTERS[1:fin], each = 2)
pt$allee <- allee
mf_label(pt, var = "allee", col= "red", halo = T)
```

éclatement allées

```{r}
allee <- st_cast(chemin, do_split = T, "")
chemin
pt
allee
mf_map(allee)

faireLg <- function (allee){
  pt <- pt [pt$allee == allee,]
  lg <- st_cast(st_union(pt$geom [1], pt$geom [2]), "LINESTRING")
  lg <- st_as_sf(data.frame(allee,lg))
}

pt
lgA <- faireLg ("A")
lgB <- faireLg ("B")
lg <- rbind(lgA, lgB)
class(lg)
mf_map(lg)
lg
lgB <- faireLg ("B")
class(lg)

lg <- lapply(LETTERS[1:fin], faireLg)
lg [[1]]

lg

do.call(rbind, lg)


  library (dplyr)
  df <- ldply (lg, data.frame)

i <- 12
df <- NULL
tmp <- NULL
for (i in 1:15) {
  allee <- LETTERS[i]
  tmp <- faireLg(allee)
  df <- rbind(df, tmp)
}
df
tail(df)
mf_map(df)
st_is_valid(df)
lgL
st_make_valid(lgL)
lgL <- faireLg("L")
lgL
str(lgA)
`st_crs<-`()
df <- st_sf(df)
plot(df)
class(df)
str(df)
tmp <- faireLg(LETTERS[1:fin])
str(df)
mf_map(df)
mf_map(df$geometry [[2]], lwd = 2, col = "blue")
df$allee
st_sfc
```



intersection chemin - tombe + centroid

```{r}
sep <- st_centroid(st_intersection(requiem, chemin))


st_linestring()

p1 <- structure(c(0, 1, 3, 2, 1, 0, 0, 0, 2, 4, 4, 0), .Dim = c(6L, 2L))
p2 <- structure(c(1, 1, 2, 1, 1, 2, 2, 1), .Dim = c(4L, 2L))
st_polygon(list(p1, p2))
mls <- st_cast(nc$geometry[[4]], "MULTILINESTRING")
st_sfc(cast_all(mls))
mpt <- st_cast(nc$geometry[[4]], "MULTIPOINT")
st_sfc(cast_all(mpt))
pl <- st_cast(nc$geometry[[4]], "POLYGON")
st_sfc(cast_all(pl))
ls <- st_cast(nc$geometry[[4]], "LINESTRING")
st_sfc(cast_all(ls))
pt <- st_cast(nc$geometry[[4]], "POINT")

```

# Traitement


```{r}
# bizarre les pts n'appartiennent pas à la lg
st_intersection(sep, chemin)
st_touches(sep, chemin)
st_contains(allee, chemin)
# allee dans le bon ordre
allee <- allee [order (allee$allée),]
# necessite d'y mettre une distance
accroch <- st_is_within_distance(sep, allee, 1)
# verif toutes les sépultures liées à une allée
serie <- sapply(accroch, length)
lg <- which(serie == 0)
mf_map(allee)
mf_label(allee, var ="allée",add =T)
mf_map(sep, add = T)
mf_map(requiem, add = T)
```

# Traitement

verif nb de tombes par allée

```{r}
table(unlist(accroch))
```



```{r}
sep$allee <- unlist(accroch)
lettre <- LETTERS[1:10]
sep$alleeL <- LETTERS[sep$allee]
```



Mesure de la distance entre le pt 0 de l'allée et le pt Sepulture


```{r}
impairs <- seq(1, 20, by = 2)
pairs
ptAllee
ptAlleeDep <- ptAllee [impairs,c("allée")]
# verif graphique
mf_map(ptAlleeDep, add =T, col = "red")
# fonction pour classer les pts
mesurer <- function (allee){
  selSep <-  sep [sep$alleeL == LETTERS [allee],]
  mat <- st_distance(ptAlleeDep [ptAlleeDep$allée == LETTERS [allee],], selSep )
  dist <- as.vector (mat)
  selSep$dist <- dist
  selSep <- selSep [order(selSep$dist),]
  seq <- (1:length(selSep$id))
  selSep$num  <- seq
  selSep <- selSep[, c("id", "alleeL", "num")]
  return(selSep)
}
# boucle car la liste difficile à manipuler
res <- NULL
for (i in 1:10){
  tmp <- mesurer (i)
  res <- rbind(tmp, res)
}
st_write(res, "../data/cimetiere.gpkg", "ptSepultureID", delete_layer = T)
```

# intégration dans le dessin des tombes


```{r}

jointureSpatiale <- st_within(res, requiem, sparse = T)
lg <- unlist(jointureSpatiale)
res$lg <- lg
res <- st_drop_geometry(res)
requiem$lg <- rownames(requiem)
joint <- merge(requiem, res, by = "lg")
mf_map(joint, col="green", add = T)
mf_label(joint, var = "num")
```



shape final

```{r}
joint <- joint [order(joint$alleeL, joint$num),]
joint$lg <- seq(1:39)
joint
joint$E_ID <- paste0("bondy@",joint$lg)
joint$ALLEE <- joint$alleeL
joint$DIVISION <- "AA"
joint$EMPLACEMEN <- joint$num
st_write(joint [, c("E_ID", "Text", "DIVISION", "SECTION", "ALLEE", "EMPLACEMEN")],"../data/bondy.shp")
```


