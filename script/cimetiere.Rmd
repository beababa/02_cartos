---
title: "cimetiere"
author: "B. Maranget"
date: "12/06/2023"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

identification tombes du cimetière

Sous Qgis, on crée les polygones des sépultures et un chemin qui permet de les numéroter.

on extrait les sommets du chemin afin de pouvoir récupérer les allées dont on garde le sens.

on intersecte le chemin et les sépultures afin de récupérer les pts sépultures.

puis on replace les sépultures sur les allées et on calcule la distance à partir de chaque point zéro de l'allée.

La dernière opération (intersection pt sépultures et allée) ne fonctionne pas sous Qgis


Simplification : éviter la phase allée
on intersecte, on numérote tous les centroïdes et on supprime les centroides qui n'intersectent

le problème est que l'indexation n'est pas conservée



```{r}
library(sf)
library(mapsf)
#library(rgdal)
```


# Chemin data


```{r, eval = T}
# on reprend variable HOME en fonction PC
rep <- Sys.getenv("HOME")
st_layers("../data/cimetiere.gpkg")
rep <- "D:/03_SIG/03_03_Data/08_VOIRIE/cimetiere.gpkg"
```


```{r}
#allee <- st_read("../data/cimetiere.gpkg", "lgAllee")
#sep <- st_read("../data/cimetiere.gpkg", "ptSepulture")
#ptAllee  <- st_read("../data/cimetiere.gpkg", "ptAllee")
chemin <- st_read("../data/cimetiere.gpkg", "chemin")
requiem <- st_read("../data/cimetiere.gpkg", "requiem")# le dessin des sépultures
```


# Prétraitement 


TO DO trouver comment extraire les sommets sous R

st_reverse points devient ligne
st_node ajoute des noeuds aux intersections
... tout simplement st_cast

```{r}
mf_map(chemin)
chemin$num <- rownames(chemin)
mf_label(chemin, var = "num")
```



choix du chemin 


```{r}
chemin <- chemin [6,]
```



```{r}
# caster un hemin en pt permet de garder l'indexation à chaque vertex
pt <- st_cast(chemin, "POINT")
mf_init(chemin)
mf_map(requiem, add = T, col = "green")
mf_map(chemin, add = T)
mf_map(pt, add = T)
pt$id <- rownames(pt)
mf_label(pt, var = "id", halo = T)
```


repérage des lignes allée

On voit qu'il faut joindre les pts 2 à 2

Mais pas toujours... faire attention au moment du dessin


```{r}
fin <- (length(pt$id)/2)
allee <- rep(LETTERS[1:fin], each = 2)
pt$allee <- allee
mf_label(pt, var = "allee", col= "red", halo = T)
```

dans le cas où le dessin est mauvais, on supprime :

Que le dessin soit mauvais, c'est inévitable quand la numérotation ne suit pas un ordre logique dans l'espace.

L'automatisation serait de repérer les allées sans pt sépulture.

C'est le cas de la section S où on a carrément pris une rangée en plus



```{r}
mf_label(pt, var = "id", col = "red", halo = T)
pt <- pt [!pt$id %in% c("6.2", "6.3","6.4", "6.5", "6.6"),]
#logiquement le pt origine est le pt impair.
pt$origine <- c("oui", "non")
fin <- length(pt$num)
```


intersection chemin - tombe + centroid

```{r}
ptSep <- st_centroid(st_intersection(requiem$geom, chemin))
```



TO DO : lister tous les autres cas.

automatisation : intégration dans la fonction de la suppression des lignes qui n'ont pas de sépulture


éclatement allées
fonction pour faire lg à partir de deux points en distinguant les pts origine pour chq allée

```{r}
allee <- "A"
faireLg <- function (allee){
  pt <- pt [pt$allee == allee,]
  lg <- st_cast(st_union(pt$geom [1], pt$geom [2]), "LINESTRING")
  # automatisation
  st_within(ptSep, lg,1)
  ifelse (st_within(ptSep))
  lg <- st_as_sf(data.frame(allee,lg))
}

lg <- lapply(LETTERS[1:fin], faireLg)
allee <- do.call(rbind, lg)
allee
mf_map(allee)
```

On a des allées



# Traitement


```{r}
# bizarre les pts n'appartiennent pas à la lg
st_intersection(ptSep, allee)
st_touches(ptSep, allee)
st_contains(ptSep, allee)
# allee dans le bon ordre (nécessaire uniquement si chemin paps dans le bon ordre)
allee <- allee [order (allee$allée),]
# necessite d'y mettre une distance
accroch <- st_is_within_distance(ptSep, allee, 1)
# verif toutes les sépultures liées à une allée
# 
serie <- sapply(accroch, length)
lg <- which(serie == 0)
mf_init(chemin)
mf_map(requiem, add = T)
mf_map(allee, col = "red",add = T)
mf_label(allee, var ="allee")
mf_map(sep, add = T)



```

# Traitement

verif nb de tombes par allée

```{r}
table(unlist(accroch))
```



```{r}
tmp  <- unlist(accroch)
sep
lettre <- LETTERS[1:10]qg
sep$alleeL <- LETTERS[sep$allee]
```



Mesure de la distance entre le pt 0 de l'allée et le pt Sepulture


```{r}
impairs <- seq(1, length(sep$id), by = 2)
pt
ptAlleeDep <- pt [impairs,c("allee")]
# verif graphique
mf_map(ptAlleeDep, add =T, col = "red")
# fonction pour classer les pts
mesurer <- function (allee){
  selSep <-  sep [sep$alleeL == LETTERS [allee],]
  mat <- st_distance(ptAlleeDep [ptAlleeDep$allée == LETTERS [allee],], selSep )
  dist <- as.vector (mat)
  selSep$dist <- dist
  selSep <- selSep [order(selSep$dist),]
  seq <- (1:length(selSep$id))
  selSep$num  <- seq
  selSep <- selSep[, c("id", "alleeL", "num")]
  return(selSep)
}
# boucle car la liste difficile à manipuler
res <- NULL
i <- 1
for (i in 1:10){
  tmp <- mesurer (i)
  res <- rbind(tmp, res)
}
st_write(res, "../data/cimetiere.gpkg", "ptSepultureID", delete_layer = T)
```

# intégration dans le dessin des tombes


```{r}
jointureSpatiale <- st_within(res, requiem, sparse = T)
lg <- unlist(jointureSpatiale)
res$lg <- lg
res <- st_drop_geometry(res)
requiem$lg <- rownames(requiem)
joint <- merge(requiem, res, by = "lg")
mf_map(joint, col="green", add = T)
mf_label(joint, var = "num")
```



shape final

```{r}
joint <- joint [order(joint$alleeL, joint$num),]
joint$lg <- seq(1:39)
joint
joint$E_ID <- paste0("bondy@",joint$lg)
joint$ALLEE <- joint$alleeL
joint$DIVISION <- "AA"
joint$EMPLACEMEN <- joint$num
st_write(joint [, c("E_ID", "Text", "DIVISION", "SECTION", "ALLEE", "EMPLACEMEN")],"../data/bondy.shp")
```


SIMPLIFICATION

En fait, l'intersection ne préserve pas l' ordre. il faudrait constituer un graphe (pt origine et destination)
c'est la distance par rapport à un pt origine pour chq allée qui permet de régler le problème.



```{r}
pt <- st_centroid(st_intersection(chemin, requiem$geom))
inter <- st_intersection(chemin, requiem)
inter$id <- rownames(inter)
inter$id
mf_map(pt, col = "red", add = T)
pt$id <- seq(1, length(pt$num))
st_within(pt, requiem)
mf_init(chemin)
mf_map(requiem  [2857,], col= "blue", add = T)   
mf_label(pt, var = "id",  col = "black", halo = T)
mf_label(inter, var = "id", col = "green")
```

matrice de distance pour constituer le graphe ?

```{r}
st_distance(pt)
```

TO DO piste ?
