---
title: "Habitat social"
author: "B. Maranget"
date: "20/10/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

Carto de l'habitat social à partir de l'inventaire logement social.
Le cadastre (données majic 3 - 2021) permet de compléter les données.


Les données sont dans logement.gpkg, la partie *préparation* permet de les constituer.
Les chunks ne se rejouent donc pas.

# Environnement

## Chemins

```{r, eval=TRUE}
if (Sys.getenv('HOME') == "/home/tachasa") {
  chemin <- paste0(Sys.getenv('HOME'), "/00_DATA/")
} else {
  chemin <- "G:/03_SIG/03_Data/"
}
```

## Librairies

```{r, eval=TRUE}
library(sf)
library(mapsf)
library(rgdal)
```







# Préparation données

Toutes les couches sont enregistrées dans logement.gpkg

## Fond de carte

### Classiques

Limites de Bondy, rues principales, cadastre en geojson (Etalab)

https://cadastre.data.gouv.fr/data/etalab-cadastre/2021-10-01/geojson/communes/93/93010/

```{r, eval=FALSE}
bondy <- st_read(paste0(chemin,"limites.gpkg"), "bondy", quiet=F)
bondy <- st_union(bondy)
st_write(bondy,paste0(chemin,"logement.gpkg"), "bondy", delete_layer = T)
ogrListLayers(paste0(chemin, "bondy.gpkg"))
cadastre <- st_read(paste0(chemin,"03_SOCLE/etalab/cadastre-93010-parcelles.json"))
cadastre <- st_transform(cadastre, 2154)
st_write(cadastre,paste0(chemin,"logement.gpkg"), "parcelles", delete_layer = T)
batCadastre <- st_read(paste0(chemin,"03_SOCLE/etalab/cadastre-93010-batiments.json"))
batCadastre <- st_transform(batCadastre, 2154)
st_write(batCadastre,paste0(chemin,"logement.gpkg"), "batCadastre", delete_layer = T)
```


reprise de toutes les rues pour dégager les grands axes autoroute et nationale

```{r, eval=FALSE}
rue <- st_read(paste0(chemin, "01_OSM/rue.geojson"))
sort(table(rue$highway))
rue <- st_transform(rue, 2154)
str(rue)
rue <- rue [, c("name","highway")]
st_write(rue, paste0(chemin, "logement.gpkg"),"rueNom", delete_layer = T)
rue <- rue [rue$highway %in% c('motorway','primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary'),]
rue <- rue [,"highway", drop = F]
mf_map(bondy)
mf_typo(rue, var = "highway", border = NA,add = T, pal = c("red", "orange", "orange", "orange", "orange", "white"), lwd = 1.5, leg_pos = "n")
st_write(rue, paste0(chemin, "logement.gpkg"), "rue", delete_layer = T)
```


Problème sur l'axe blum / 


le canal

```{r, eval=FALSE}
canal <- st_read(paste0(chemin, "01_OSM/canal.geojson"))
canal <- st_transform(canal, 2154)
st_write (canal, paste0(chemin, "logement.gpkg"), "canal", delete_layer = T)
```


### Pru

Qpv, limites PRU (à dessiner)

```{r, eval=FALSE}
qpv <- st_read(paste0(chemin, "limites.gpkg"), "qpv1")
qpv <- st_intersection(bondy, qpv)
st_write(qpv,paste0(chemin,"logement.gpkg"), "qpv", delete_layer = T)
```


### Couches OSM

couches OSM susceptibles d'être complétées :

- Parcs et jardins (leisure = park)

- Batiments publics (building = public)

```{r, eval=FALSE}
jardin <- st_read(paste0(chemin,"park.geojson"))
bat <- st_read(paste0(chemin, "building.geojson"))
jardin <- st_transform(jardin, 2154)
# pb jardin multipolkygone, on fusionne
jardin <- st_union(jardin)
bat <- st_transform(bat, 2154)
st_write(jardin, paste0(chemin, "logement.gpkg"), "jardin", delete_layer = T)
st_write(bat, paste0(chemin, "logement.gpkg"), "bat", delete_layer = T)
```


### Elements du fond de carte

#### Chargement des couches

```{r, eval = TRUE}
#readOGR(paste0(chemin, "logement.gpkg"))
couche <- ogrListLayers(paste0(chemin, "logement.gpkg"))
for (i in 1:length(couche)){
    objet <- st_read(paste0(chemin, "logement.gpkg"), couche [i])
    assign(couche [i], objet)
}
length(couche)
```

12 couchnes

#### Carto


```{r}
mf_init(bondy, theme = "candy")
mf_shadow(bondy, add = TRUE)
fond <- function(){
  mf_map(bondy, add = T)
mf_typo(rue, var = "highway", border = NA,add = T, pal = c("red", "orange", "orange", "orange", "orange", "white"), lwd = 1.5, leg_pos = "n")
mf_map(jardin, col = "chartreuse3", border = NA,add = T)
mf_map(bat, col = "antiquewhite1", border = NA,add = T)
mf_map(canal, col = "cadetblue1", lwd = 2, border = NA, add = T)
mf_map(qpv, col = NA, border = "#990066", lwd = 1, add = T)
}
fond()
mf_layout(title = "Fond de carte", credits = "OSM" )
```



## Inventaire habitat social

Fichier d'adresse en jointure sur la couche de dessin du cadastre en opendata

### Récupération du géocodage

```{r}
data <- read.csv( "../data/logement.geocoded.geocoded.csv", encoding = "UTF-8")
data <- st_as_sf(data, coords =c("longitude", "latitude"), crs = 4326)
data <- st_transform(data, 2154)
st_write(data, paste0( chemin,"logement.gpkg"), "habitat2", delete_layer = T )
```


152 adresses au premier tour, 151 au second...

couches habitat et habiat2


```{r}
habitat <- st_read(paste0(chemin, "logement.gpkg"), "habitat", quiet = T)
habitat2 <- st_read(paste0(chemin, "logement.gpkg"), "habitat2", quiet = T)
mf_init(data, theme = "candy")
mf_shadow(bondy, add = TRUE)
fond()
map_habitat <- function(data1, data2){
  mf_map(data1, pch = 19, col = "red", add = T)
mf_map(data2, pch = 19,col = "green", add = T)

mf_legend_s(pt_cex = c(1,1), pt_pch = c(21,21), val = c("1er essai", "2e essai"), pal = c("red", "green"), title = "")
}
map_habitat(habitat, habitat2)
mf_layout(title = "Géocodage : 2 essais", credits = "Inventaire logement social")
```

carte des plus gros logements (> 100)

```{r}
habitatGros <- habitat [habitat$nb.logements > 100,]
habitatGros2 <- habitat2 [habitat2$nb.logements > 100,]
mf_init(data, theme = "candy")
mf_shadow(bondy, add = TRUE)
fond()
map_habitat(habitatGros, habitatGros2)
mf_label(habitatGros, var = "nb.logements", 
         col = "red", halo = T, lines = T, pos = 1, offset = 0.2)
mf_layout(title = "Géocodage : 2 essais (> 100 logements)", credits = "Inventaire logement social\nBondy, janvier 2022")
```

zoom sur zone dense 

```{r}
pt <- habitat [habitat$Nom.de.voie == "SUZANNE BUISSON",]
tampon <- st_buffer(pt,100)
mf_init(tampon, theme = "candy")
mf_shadow(bondy, add = TRUE)
fond()
mf_map(parcelles, col = "antiquewhite2", border = NA,add = TRUE)
mf_map(batCadastre, col = "antiquewhite3", border = NA, add = T)
mf_map(qpv, col = NA, border = "#990066", lwd = 1, add = T)
map_habitat(habitatGros, habitatGros2)
mf_label(habitatGros, var = "nb.logements", 
         col = "red", halo = T, lines = T, pos = 1, offset = 0.2)
mf_label(habitatGros2, var = "nb.logements", 
         col = "green", halo = T, bg = "black",lines = T, pos = 3, offset = 0.4)
mf_layout(title = "Géocodage : différenece relative entre 2 essais (> 100 logements, zone dense)", credits = "Inventaire logement social\nBondy, janvier 2022")
```




### Zones denses

On note les zones denses pour pouvoir zoomer et étudier ces zones en priorité.
Les zones denses sont celles où il y a le plus d'adresses.

```{r}
# création d'une grille et du nb de points par carreau
grille <- st_make_grid(bondy, cellsize = c(200,200))
res <- st_intersects(grille, data)
densite <- sapply(res, length)
barplot(table(densite), main = "Nb d'adresses par carreau 200*200", sub = "(152 adresses au total)", xlab = "Nb d'adresses", ylab = "Occurences")
grilleDensite <- st_as_sf(data.frame(grille, densite))
# On choisit de prndre uniquement les carreaux avec 5 adresses, cela fait 10 zones à zoomer
grilleDensiteForte <- grilleDensite [grilleDensite$densite > 4,]
st_write(grilleDensiteForte, paste0(chemin, "logement.gpkg"), "zoom", delete_layer = T)
```

### Cartographie rapide

```{r}
zoom <- st_read(paste0(chemin, "logement.gpkg"), "zoom")
adresse <- st_read(paste0(chemin, "logement.gpkg"), "habitat")
adresse
mf_init(zoom, theme = "candy")
mf_shadow(bondy, add = TRUE)
mf_map(bondy, add = T)
mf_choro(zoom, var = "densite", border = NA,
         leg_title = "nb d'adresses", add = T)
mf_map(adresse, add = T)
zoom$id <- rownames(zoom)
mf_label(zoom, var = "id", halo = TRUE)
mf_layout(title = "152 lignes géocodées de l'inventaire social et 10 zones denses" , credits = "inventaire logements sociaux, Bondy, 2021")
```


### Utiliser les points pour les étiquettes

Essai sur les zones denses

```{r}
zoom$geom [[1]]
mf_init(zoom$geom [[1]])
mf_map(zoom, add = TRUE)
mf_shadow(zoom, add = T)
mf_typo(data, var = "organisme", add = TRUE, leg_pos = 'n')
mf_label(data, var = "organisme")
data <- st_intersection(adresse,zoom)
data <- st_jitter(data [data$id == 1,], 10)
```




## Jointure

Jointure sur parcelle pour récupérer surface plutôt que point.
Problème des multiparcelles ?

ou jointure sur bâtiment ?

Egalement problème des multi-étiquette


```{r, eval=FALSE}
jointureSpatiale <- st_intersection(data, parcelles)
# 65 pt seulement ?
pt <- data$geometry

plot(parcelles$geom)
plot(pt [1], col ="red",add = T)
plot(jointureSpatiale$geometry, col= "green",add = T)
# pourquoi le pt 1 n'intersecte pas ?
plot(pt[1])
plot(parcelles, col = "blue", add = T)
# pourquoi le pt 1 ne se superpose pas
```


On récupère la géométrie des parcelles

```{r}
dataSansGeom <- jointureSpatiale [, c("id", "organisme","Type.de.logement","nb.logements"),drop = T]
data <- merge(dataSansGeom, parcelles [, c("id")], by = "id")
data <- st_as_sf(data)
```


On a plusieurs fois les mêmes parcelles


## Etiquettes : les bailleurs

A terme, il va falloir récupérer les bailleurs

Eviter duplication de parcelle / et de nom ?

```{r}
unik <- unique(data$id)
# 53 parcelles uniques
data <- data [data$id %in% unik,]
```


65 parcelles

Fusionner les parcelles avec le même bailleur





### Zoom : points hors parcelles

```{r}
mf_export(x = bondy, filename = "../img/zoom.png", 
          expandBB = c(0,0,0,0.55),
          width = 1000, height = 500, res = 150)
par(mfrow = c(2,5))
i <- 1
for (i in 1:length(zoom$densite))
{
  mf_init(zoom$geom[i], theme = "barcelona")
  mf_shadow(bondy, add = TRUE)
  mf_map(cadastre, col = "antiquewhite1", border = "grey", add = TRUE)
  mf_map(
    data,
    type = "base",
    border = NA,
    col = "red",
    add = TRUE
  )
  mf_label(data, var = "organisme", col ="white", overlap = T, halo = T, cex = 1)
   mf_layout(title = paste("zoom ",i), credits = paste0("OSM / sources internes\n", "Bondy, 2021"))
}
dev.off()
```

![](../img/zoom.png)


Problème : les points sont hors des parcelles.

### Idée : le tampon

On crée un tampon autour des points


```{r}
dataBuffer <- st_buffer(data, 2)
# le tampon de 2 m permet de récupérer autant de géométrie que d'adresses au départ
jointureSpatiale <- st_intersection(cadastre, dataBuffer)
#On récupère la géométrie des parcelles
dataSansGeom <- jointureSpatiale [, c("id", "organisme","Type.de.logement","nb.logements"),drop = T]
data <- merge(dataSansGeom, cadastre [, c("id")], by = "id")
data <- st_as_sf(data)
```


```{r}
mf_export(x = bondy, filename = "../img/zoomBuffer.png", 
          expandBB = c(0,0,0,0.55),
          width = 1000, height = 500, res = 150)
par(mfrow = c(2,5))
i <- 1
for (i in 1:length(zoom$densite))
{
  # on fusionne les géométries avec meme organisme
  mf_init(zoom$geom[[i]], theme = "barcelona")
  mf_shadow(bondy, add = TRUE)
  mf_map(cadastre, col = "antiquewhite1", border = "grey", add = TRUE)
  mf_map(
    rue,
    type = "base",
    col = "white",
    lwd = 2,
    add = TRUE
  )
 mf_map(
    jointureSpatiale,
    type = "base",
    border = NA,
    col = "red",
    add = TRUE
  )
 inter <- st_intersection(jointureSpatiale, zoom$geom[i])
plot(zoom$geom [2])
plot(jointureSpatiale$geometry, add = T) 
agg <- aggregate(inter, by = list(inter$organisme), length)
mf_typo(
  agg,
  var = "Group.1",
  add = T
) 
mf_label(agg, var = "Group.1", col ="white", overlap = F, halo = T, cex = 1)
   mf_layout(title = paste("zoom ",i), credits = paste0("OSM / sources internes\n", "Bondy, 2021"))
}
dev.off()
```


![](../img/zoomBuffer.png)

### Finalisation du fichier



Rectification bailleurs


```{r}
sort(names(table(data$organisme)))
data$organisme [data$organisme == 'BATIGEREEN IDF'] <- 'BATIGERE EN IDF'
data$organisme [data$organisme == 'CDC HABIT AT SOCIAL'] <- 'CDC HABITAT SOCIAL'
st_write(data,  paste0(chemin,"logement.gpkg"), "jointure", delete_layer = T)
```





## Autre donnée disponible : cadastre edigeo


Récupération des couches cadastre via QGIS, notamment la couche parcelle_info dont
le champs *proprietaire" contient de nombreuses informations par rapport aux propriétaires.

```{r}
cadastre <- st_read(paste0(chemin,"/cadastre.sqlite"), "parcelle_info")
liste <- strsplit(cadastre$proprietaire, " - ")
cadastre$proprio_nom <- sapply(liste, '[',2)
tab <- table(cadastre$proprio_nom) 
tab <- tab [tab > 10]
grosProprio <- names(tab)
cartoGrosProprio <- cadastre [cadastre$proprio_nom %in% grosProprio,]
surface <- aggregate(st_area(cartoGrosProprio$geom)/10000, by = list(cartoGrosProprio$proprio_nom), sum)
data <- aggregate(cartoGrosProprio$geom, by = list(cartoGrosProprio$proprio_nom), st_union)
data <- st_as_sf(data)
names(data) [1] <- "Propriétaires"
```


# Explorations donnée hors cartographie

## Histogramme des bailleurs dans l'inventaire des logements sociaux


```{r}
logement <- st_read(paste0(chemin,"logement.gpkg"), "jointure")
tab <- table(logement$organisme)
hist(tab, main = "Nb d'adresses par bailleur", xlab = "Nb d'adresses", ylab = "Occurence")
bailleurs <- names(tab) [-1]
sort(bailleurs)
# construciton du motif pour les chercher dans le cadastre
motif <-  NULL
for (i in 1:length(bailleurs)){
  tmp <- paste0("\'",
               bailleurs [i],
               "\'",
               "|")
  motif <- paste0(motif, tmp)
}
logementSocial <- cadastre [cadastre$proprietaire %in% bailleurs,]
lg <- grep (motif, cadastre$proprietaire)
cadastre [lg,]
# Aucun bailleur n'est propriétaire ?
```

On récupère les bailleurs dans les logements sociaux



# Cartographie




## Nombre de logements par bailleurs


```{r}
mf_export(x = bondy, filename = "../img/pru.png", 
          expandBB = c(0,0,0,0.3),
          width = 1000, res = 250)
  mf_init(bondy, theme = "candy")
  mf_shadow(bondy, add = TRUE)
fond()
  mf_map(
    logement,
    type = "choro",
    border = NA,
    var = "nb.logements",
    leg_pos = "right",
    add = TRUE
  )

#  mf_label(data, var = "organisme", overlap = F, halo = T, cex = 0.5)
  
 # start the inset
mf_inset_on( fig = c(0.75, .95, 0.84, .99))
# draw the histogram
bks <- mf_get_breaks(x = logement$nb.logements, nbreaks = 5, breaks = "quantile") 
pal <- hcl.colors(n = 5, palette = "Dark Mint", rev = TRUE)
mf_theme("candy")
fg <-mf_theme()$fg
par(mar = c(0,0,0.8,0))
hist(logement$nb.logements, breaks = bks, col = pal, border = fg, axes = F, labels = "", 
     xlab="logements", ylab = "", main ="")
axis(side = 1, at = bks, las = 2, tick = FALSE, line = -.9, 
  cex.axis = .7, col.axis = fg)
title("Nb logements", cex.main = .5, col.main = fg, 
      font.main = 1, adj = 0)
# close the inset
mf_inset_off()
   mf_layout(title = "Habitat social",
            credits = paste0("OSM / Inventaire parcs logements sociaux\n", "Bondy, 2021"))
dev.off()
```

![](../img/pru.png)

## Carte des bailleurs

```{r}
library(mapsf)
mf_export(x = bondy, filename = "../img/pruOrganisme.png", 
          expandBB = c(0,0,0,0.55),
          width = 1000, res = 150)
mf_init(bondy, theme = "candy")
  mf_shadow(bondy, add = TRUE)
  fond()
  mf_typo(
    logement,
    border = NA,
    var = "organisme",
    cex = 0.5,
    add = TRUE
  )

  
   mf_layout(title = "Habitat social : organisme",
            credits = paste0("OSM / Inventaire parcs logements sociaux\n", "Bondy, 2021"))
dev.off()


```

![](../img/pruOrganisme.png)

## Gros propriétaires cadastre

```{r}
data$surface <- st_area(data$geometry)/10000
library(mapsf)
mf_export(x = bondy, filename = "../img/grosProprioCadastre.png", 
          expandBB = c(0,0,0,0.2),
          width = 2100,  height = 2970, res = 400)
  #mf_init(bondy, theme = "candy")
  mf_shadow(bondy, add = TRUE)
  fond()
  mf_map(
    data,
    type = "typo",
    val_order = data$Propriétaires[ order(data$surface)],
    pal = hcl.colors(n = 14, palette = "Dark Mint", rev = TRUE),
    border = NA,
    var = "Propriétaires",
    leg_pos = "n",
   
    add = TRUE
  )

#  mf_label(data, var = "organisme", overlap = F, halo = T, cex = 0.5)
  
 # start the inset
mf_inset_on( fig = c(0.75, .95, 0.84, .99))
# draw the histogram
bks <- mf_get_breaks(x = st_area(data)/10000, nbreaks = 5, breaks = "quantile") 
pal <- hcl.colors(n = 14, palette = "Dark Mint", rev = TRUE)
mf_theme("candy")
fg <-mf_theme()$fg
par(mar = c(0,0,0.8,0))


barplot(sort(data$surface), names.arg = data$Propriétaires[ order(data$surface)], las = 2, ylab = "surface (hac)", col = pal, cex.names = 0.4, axes = F)
axis(side = 4, at = c(1,50), las = 2, tick = FALSE, line = -.9, 
  cex.axis = .7, col.axis = fg)

title("Surface (ha) / propriétaire", cex.main = .5, col.main = fg, 
      font.main = 1, adj = 0)


# close the inset
mf_inset_off()
   mf_layout(title = "Propriétaires, plus de 10 parcelles",
            credits = paste0("OSM / Cadastre, 2021\n", "Bondy, 2021"))
dev.off()
```


![](../img/grosProprioCadastre.png)
