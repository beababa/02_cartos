---
title: "Renaturation"
author: "B. Maranget"
date: "28/04/2022"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

A l'occasion du 2e atelier renaturation, un lien entre les parcelles potentiel et les ADS est demandé.

L'export des ADS se fait à partir de la recherche avancée Bondy / y compris les dossiers clos ()

```{r}
library(sf)
library(mapsf)
```


# Chemin data


```{r, eval = T}
chemin <-  paste0(Sys.getenv('HOME'), "/03_SIG/03_03_Data/")
```


# Données

fichier des ADS + fichier parcelle + cadastre

la difficulté identifiée est le numéro de parcelle

```{r}
#02_URBA pour le drive 06 pour pc mairie
st_layers("../data/limitesSocle.gpkg")
bondy <- st_read("../data/limitesSocle.gpkg", "bondy")
st_layers("../data/cadastre.gpkg") 
cadastre <- st_read("../data/cadastre.gpkg", "parcelleAdresse")
pmorale <- st_read("../data/cadastre.gpkg", "pmoraleOpendata")
ads <- read.csv(paste0(chemin, "15_PARCS ET JARDINS/ads.csv"), fileEncoding = "UTF-8")
potentiel <-  read.csv(paste0(chemin, "15_PARCS ET JARDINS/parcellePotentiel.csv"), fileEncoding = "UTF-8")
```


cadastre : pas de zéro avt la section cadastrale


```{r}
table(sapply(cadastre$code, nchar))
substr(cadastre$code,1,3)
cadastre [268,]
# Eclatemetn de la chaine et extraction 1er terme
eclate <- strsplit(ads$Parcelles, ",")
ads$Parcelles2 <- sapply(eclate, "[",1)
# 3 % du total
tab <- addmargins(table(is.na(ads$Parcelles2)))
prop.table(table(is.na(ads$Parcelles2)))*100
ads$Parcelles2 <- gsub(" ", "", ads$Parcelles2)
ads$num <- gsub("[A-Z]", "", ads$Parcelles2)
ads$section <- gsub("[0-9]","", ads$Parcelles2)
# rajout des zéros
potentiel$code <- substr(potentiel$N.PARCELLE,10,19)
potentiel$code
ads$numNB <- nchar(ads$num)
ads$sectionNB <- nchar(ads$section)
#ads$section <- ifelse(ads$sectionNB == 1 , paste0("0",ads$section), ads$section)
ads$num2 <- ifelse(ads$numNB == 1, paste0("000", ads$num),
               ifelse(ads$numNB == 2,paste0("00", ads$num),
                 ifelse(ads$numNB == 3, paste0("0", ads$num), ads$num)))
ads$num2
ads$code <- paste0(ads$section, ads$num2)
cadastre$code
res <- merge(cadastre, ads, by = "code")
# 282 sur 
potentiel$code <- gsub("^0", "", potentiel$code)
res <- merge(res, potentiel, by = "code")
mf_map(bondy)
st_layers("../data/cadastre.gpkg")
section <- st_read("../data/cadastre.gpkg", "section")
mf_map(section, add = T)
mf_label(section, var = "tex")
mf_map(res, add = T)
```


# Traitement

Intersection rue et cadastre pour récupérer les rues non cadastrées
On récupère en fait le nb d'intersection que l'on rend booléen

```{r}
inter <- st_intersection(rue, cadastre)
interMat <- st_intersects (rue, cadastre)
length(interMat [[6]])
# les lignes vides marquent les rues non cadastrées.
rue$inter <- sapply(interMat, length)
table(rue$inter)
# longueur rue non cadastré
rueNonCadastre <- rue [rue$inter == 0,]
sum(st_length(rueNonCadastre))
# on met à jour le champs longueur également
rue$Longueur <- st_length(rue)
```

57 km de voirie non cadastrée.

```{r}
rueCadastre <- rue [rue$inter != 0,]
sum(st_length(rueCadastre))
```

36 km de voirie cadastrée


```{r}
table(rue$inter)
rue$cadastre <- ifelse(rue$inter == 0, "non", "oui") 
tab  <- aggregate(st_length(rue), by = list(rue$cadastre), sum)
st_write(rue, paste0(chemin, "03_sOCLE/rue.gpkg"), "rueCadastre", delete_layer = T)
```


Reprise de l'attribut

```{r}
rue <- st_read(paste0(chemin,"03_SOCLE/rue.gpkg"), "rueCadastre")
str(rue)
# éclatement terme et nom rue

```


Rectification à la main pour les rues cadastrées ou non

```{r}
rue <- st_read(paste0(chemin,"03_SOCLE/rue2023.gpkg"))
# Ecrasement du fichier d'origine
st_write(rue, paste0(chemin, "03_sOCLE/rue.gpkg"), "rueCadastre", delete_layer = T)
```

Diff usage et logique (cadastré ou non)


Récup de l'usage à partir de la delib de 2019 (sous Qgis)
On essaie ensuite de trouver les incohérences : rues d'usage privées non cadastrées

```{r}
rue <- st_read(paste0(chemin,"03_SOCLE/rue.gpkg"), "rueCadastre")
rue$incoherence [rue$cadastre == "non"& rue$usage == "privé"] <- "incohérence"
table(rue$incoherence)
sort(rue$NOM_1_G [rue$incoherence == "incohérence"])
st_write(rue, paste0(chemin, "03_sOCLE/rue.gpkg"), "rueCadastre", delete_layer = T)
```

export liste


```{r}
str(rue)
write.csv(rue [ , c("NATURE", "NOM","Longueur", "NOMnumero", "cadastre", "usage", "incoherence"), drop = TRUE], "../data/ruePriveNonCadastre.csv",  fileEncoding = "UTF-8")
```

export num rues

```{r}
petiteRue <- rue [!is.na(rue$NOMnumero), c("NOMnumero", "NOM"), drop = T]
names(petiteRue) <- c("Nom", "numéro")
petiteRue$numéro <- as.integer(petiteRue$numéro)
petiteRue <- petiteRue [order(petiteRue$numéro),]
write.csv(petiteRue, "../data/petiteRue.csv", fileEncoding = "UTF-8", row.names = F)
```



# Cartographie


rue cadastrée / non cadastrée

```{r}
png("../img/inter.png", width = 1000, height = 1200, res = 120)
mf_init(rue)
mf_map(cadastre, col = "antiquewhite2", border = "antiquewhite1", add = T)
mf_map(rue, type = "typo" , var = "cadastre", pal = c("darkorange1", "darkolivegreen2"), leg_pos = NA, add = T)
mf_inset_on(fig = c(0.75, 0.95, 0.84, .99))
# draw the histogram
par(mar = c(0, 0, 1.7, 0))
barplot(table(rue$cadastre), col = c("darkorange1", "darkolivegreen2"), border = NA,
  axes = F, names.arg = "",
  xlab = "", ylab = "", main = "", space=0, width = 0.1, xlim = c(0,1)
)
axis(
  side = 1, las = 2, tick = FALSE, line = -.9,
  cex.axis = .5, labels = c("non", "oui"), at = c(0.03,0.14)
)
axis(
  side = 2, las = 2, tick = T, 
  cex.axis = .5
)

title("nb rues",
  cex.main = .8,
  font.main = 1, adj = 0
)
# close the inset
mf_inset_off()
# Add map layout
mf_layout("Distinction voirie cadastrée / non cadastrée", "sources : cadastre 2022 & rues")
dev.off()
```

![](../img/inter.png)

rue incohérente


```{r}
png("../img/incoherence.png", width = 1000, height = 1200, res = 120)
mf_init(rue [rue$incoherence == "incohérence",])
mf_map(cadastre, col = "antiquewhite2", border = "antiquewhite1", add = T)
mf_map(rue , type = "typo" , var = "incoherence", pal = c("darkorange1", "darkolivegreen2"), leg_pos = NA, add = T)
mf_label(rue [rue$incoherence == "incohérence",], var = "NOM")
# Add map layout
mf_layout("Voirie non cadastrée et pourtant privée", "sources : cadastre 2022 & rues")
dev.off()
```

