---
title: "Recup fichier ads"
author: "B. Maranget"
date: "20/10/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

reprise de données ADS pour Operis - Oxalis


# Conversion XLS CSV

A ne faire qu'une fois pour pouvoir travailler sur le linux

```{r, eval=FALSE}
library(xlsx)
library(readxl)
ADSOp <- read.xlsx("../data/Format_ADS2007.xls", startRow= 1, header = TRUE,sheetIndex = 1, encoding = "UTF-8")
write.csv(ADSOp, "../data/adsOp.csv", fileEncoding = "UTF-8")
i <- 1
for (i in 1:10) {
  data <- read_excel("../data/REGISTRE ADS.xls", sheet = i)
  write.csv(data, paste0("../data/ads", i, ".csv"), na ="", fileEncoding = "UTF-8")
}
```

# Nettoyage du fichier 

Pb d'encodage sur lg de titre, on ouvre avec libre office
TODO retester avec un enregistrement en UTF-8

```{r}
registre <- read.csv("../data/ads1b.csv", encoding="UTF-8")
# 26 colonnes uniquement et 5358 dossiers
noms <- names(registre)[1:26]
registre <- registre [c(1:5358), noms]
```

Etablissement de la table d'équivalence

```{r}
modele <-  read.csv("../data/adsOp1.csv", encoding="UTF-8")
equiv <- modele [,c("COLONNES", "MAIRIE", "MAIRIE.2")]
```

Construction du df d'arrivée

58 colonnes

création d'une matrice convertie ensuite en df

```{r}
nomsModele <- modele$COLONNES
nbData <- length(nomsModele)*length(registre$X)
df <-  NA
df <- matrix(data = 0,nrow = 5358, ncol = 58)
df <- data.frame(df)
names(df) <- nomsModele
```



Equivalence simple

On prend la table des équivalences, certaines colonnes ne fonctionneront pas mais
le try permettra de gérer l'erreur
Pour les noms de colonnes avec des "'" et des " ", on remplace par des points

```{r}
equiv$MAIRIE3 <- gsub(" |'", ".",equiv$MAIRIE)
for (i in 1:58) {
  print(i)
  try(df [ , equiv$COLONNES [i]] <- registre [,equiv$MAIRIE3[i]])
}
write.csv(df, "../data/premierJet.csv", fileEncoding = "UTF-8")
```

# Les parcelles

Les parcelles : section et numéro

Le problème

Il y a deux colonnes qu'il faut concaténer mais pl sections et pl numéros

sous problème

- espace

- séparateur

```{r}
head(registre [, c("section.cadastrale","n..parcelle")],20)
```

## Repérer les lignes problèmatiques

### Section : lignes vides

Envoyer les lignes sans numéros de section pour vérif

```{r}
export <- registre [registre$section.cadastrale == "",]
write.csv (export, "../data/registreSansSection.csv", fileEncoding = "UTF-8")
95/5358
```

95 lignes sans numéro de section...(moins de 2 % des lignes) A voir avec Rabia

La vérif est trop longue voir si on peut passer par des adresses

On importe les majic et l'edigeo dans qgis et on exporte en gpkg la table parcelleInfo



```{r}
library(sf)
export$adresse.du.chantier
export$Numéro
adresse <- export [, c("adresse.du.chantier", "Numéro")]
cadastre <- st_read("../data/cadastre.gpkg", "parcelleAdresse")
cadastre <- cadastre [, c("geo_parcelle","proprietaire_info")]
head(adresse)
head(cadastre)
eclate <- strsplit(cadastre$proprietaire_info , "- ")
cadastre$adresse <- sapply(eclate, "[",2)
cadastre$adresse
adresse$adresse.du.chantier
```



### Longueur du champs

Beaucoup d'espaces dans les champs, donc on les supprime, puis on pointe les champs
dont la longueur indiquent un problème.

Toutes les lignes > 2 posent pb

```{r}
extraction <- registre [ nchar(registre$section.cadastrale) > 2, ]
extraction$section.cadastrale
# pour les parcelles  on supprime les double espaces
registre$n..parcelle <- gsub ("  ", "" , registre$n..parcelle) 
head(registre$n..parcelle)
extraction <- registre [nchar(gsub ("  ", "" , registre$n..parcelle)) > 4, ]
extraction$n..parcelle
```

720 lignes pose problème

Lignes avec un chiffre décimal (voir avec Rabia)

```{r}
ind <- grep ("\\.",extraction$n..parcelle )
extraction$n..parcelle [ind]
write.csv(extraction, "../data/exportPbPointParcelle.csv", fileEncoding =  "UTF-8")
```

45 lignes à traiter plus tard

On utilise les variables texte et texteCol

## Suprression des espaces

La colonne n..parcelle comporte des numéros séparés par pl espace
Idem pour la colonne section cadastrale

Démarche pour la section

- remplacement de tous les caractères de séparation par un caractère unique (l'espace)
- remplacement de 1er espace par un ;
- suppression de tous les espaces restants


Cela ne fonctionne que si 2 éléments... ce qui est le cas pour les sections.

```{r}
texte <- extraction
texteCol <- extraction$section.cadastrale
ch <- "','&'et'&/'\n'&'à'&'/'&'-'"
chTot <- paste0("[",ch,"]")
testSection <- gsub(chTot, " ", registre$section.cadastrale)
testSection <- sub(" ",";",registre$section.cadastrale)
testSection <- gsub(" ","", testSection)
testParcelle <- sub(" ", ";", registre$n..parcelle)
testParcelle <- gsub (" ", "", testParcelle)
export <- cbind(testSection, testParcelle,  registre$section.cadastrale, registre$n..parcelle)
write.csv(export, "../data/export.csv", fileEncoding = "UTF-8")
```

tests divers

Comparaison nb cas avant et après

```{r}
nbDeb <- length(grep(chTot, registre$section.cadastrale))
nbFin <- length(grep(chTot, testSection))
```

C'est bizarre, il faut passer plusieurs fois gsub ? Pb du t qui disparaît


plusieurs shémas à rassembler en un. / , et espace deviennent uniquement /
puis on adjoint la section à chaque numparcelle

```{r}

strsplit(test, " |/|,\.")
```


# Les dates

Pour les dates, on reprend la démarche DIA, on liste les champs à date. 
On répare les anomalies puis on convertit (attention à l'export)

```{r}
# dates
str(registre)
registre$date.de.la.demande <-as.Date(registre$date.de.la.demande, origin = "1900-01-01")
pb <- which(!(substring(registre$date.de.la.demande, 0,2)  %in% c("36","37", "38","39", "40","41","42","43","44")))
registre$date.de.la.demande [pb]
write.csv(registre$date.de.la.demande [pb], "data/pbDate.csv")
equiv <- read.csv("data/pbDateOk.csv")
equiv <- equiv [-26, c(1:3)]
# conversion en chiffre csv
equiv$ok <- as.Date(equiv$ok, format = "%d/%m/%y", origin = "")
equiv$ok <- as.integer(equiv$ok)
equiv$ok
registre$date.de.la.demande [pb] <- equiv$ok
```
