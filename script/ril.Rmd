---
title: "ril : pb extraction fichier"
author: "B. Maranget"
date: "27/02/2023"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

le RIL a un champs qui commentaire qui pose un pb de décalage poru les champs X, Y dans QGIS
(pas dans libre office, ni excel)

dans RORCAL, il s'agit de 99 EA, le fichier d'export n'en fait que 91. TODO

faire également l'intersection.

# Environnement


## Librairies


```{r}
library(sf)
library(mapsf)
```


## Chemins


```{r}
chemin <- "C:/Users/bmaranget/Documents/03_SIG/03_03_Data/11_RIL/"
chemin2 <- "C:/Users/bmaranget/Documents/03_SIG/03_03_Data/03_SOCLE/"
```



# données



```{r}
ril <- read.csv2("../data/rilFevrier2023.csv", fileEncoding = "UTF-8", dec =".", skip = 1)
str(ril)
# spatialisation
ril <- st_as_sf(ril, coords = c("x", "y"), crs = 2154 )
st_layers("../data/ril.gpkg")
st_write(ril, "../data/ril.gpkg", "rilFev2023", delete_layer = T)

```

les zones de sortie

elles sont dessinées sous qgis, puis l'intersection est faite sous R


```{r}
zone <- st_read("../data/ril.gpkg", "zonesDeSortie")
ril <- st_intersection(ril, zone)
ril <- ril [, c("numero", "repetition", "complement", "type_voie", "libelle", "nombre_logements", "numero_permis", "commentaire", "zone")]
st_write(ril, "../data/ril.gpkg", "rilFev2023", delete_layer = T)
str(ril)

write.csv(st_drop_geometry(ril),"../data/ril.csv", fileEncoding = "UTF-8")
```

nb de points pour chaque sortie

```{r}
agg <- aggregate(ril [, "zone"], by = list(ril$zone), length)
# verif
sum(agg$zone)
zone <- merge (st_drop_geometry(agg), zone, by.x = "Group.1", by.y = "zone")
st_write(zone, "../data/ril.gpkg", "zonesDeSortie", delete_layer = T)
```




# Les parcelles

pl parcelles possibles, par exemple :

```{r}
str(ads)
ads [3, c("Parcelles")]
# attention à l'espace égalemetn
cadastre$code <- gsub("^ ","", cadastre$code)
cadastre$section <- substring(cadastre$code,1,2)
cadastre$section <- gsub("0", "", cadastre$section)
tail(cadastre$section)
cadastre$parcelle <- substring(cadastre$code, 3,10)
cadastre$parcelle <- as.integer(cadastre$parcelle)
cadastre$parcelle
cadastre$code2 <- paste0(cadastre$section, cadastre$parcelle)
cadastre$code2
ads$Parcelles <- gsub(" ","", ads$Parcelles)
```

Eclatement et recup de la première parcelle et du nb de parcelles

```{r}
liste <- strsplit( ads$Parcelles, ",")
liste1 <- sapply(ads$Parcelles, "[",1)
nb <- sapply(liste, length)
nb[160]
liste[160]
table(nb)
```

On va traiter à part les multi parcelles un par un ?

```{r}
fusion <- unlist(liste[[160]])
cadastreSelFus <- st_union( cadastre [cadastre$code2 %in% fusion,])
mf_map(cadastreSelFus)
mf_label( cadastre [cadastre$code2 %in% fusion,] , "code2")
mf_map(cadastre, col = NA, border = "black", add = T)
cadastre [160,]
mf_label(rue, "NOM_1_G")
```



# Jointure attributaire

ads$Parcelles et cadastre$code2

```{r}
data <- merge(cadastre, ads, by.x = "code2", by.y = "Parcelles")
```


* Suppressions des vides, traitement avec le cadastre correspondance parcelle - adresse





## Repérer les lignes problèmatiques


Envoyer les lignes sans numéros de section pour vérif

```{r}
export <- registre [registre$section.cadastrale == "",]
write.csv (export, "../data/registreSansSection.csv", fileEncoding = "UTF-8")
95/5358
registreF <- registre [registre$section.cadastrale != "",]
```

5263 ADS avec section

95 lignes sans numéro de section...(moins de 2 % des lignes) A voir avec Rabia

La vérif est trop longue voir si on peut passer par des adresses

#### Traitement des vides

On importe les majic et l'edigeo dans qgis et on exporte en gpkg la table parcelleInfo


```{r}
export$adresse.du.chantier
export$Numéro
adresse <- export [, c("adresse.du.chantier", "Numéro")]
cadastre <- st_read(paste0("../data/cadastre.gpkg"), "parcelleAdresse")
cadastre <- cadastre [, c("geo_parcelle","proprietaire_info")]
head(adresse)
head(cadastre)
eclate <- strsplit(cadastre$proprietaire_info , "- ")
cadastre$adresse <- sapply(eclate, "[",2)
cadastre$adresse
adresse$adresse.du.chantier
```



### Longueur du champs

Beaucoup d'espaces dans les champs, donc on les supprime, puis on pointe les champs
dont la longueur indiquent un problème.

Toutes les lignes > 2 posent pb

```{r}
extraction <- registre [ nchar(registre$section.cadastrale) > 2, ]
extraction$section.cadastrale
# pour les parcelles  on supprime les double espaces
registre$n..parcelle <- gsub ("  ", "" , registre$n..parcelle) 
head(registre$n..parcelle)
extraction <- registre [nchar(gsub ("  ", "" , registre$n..parcelle)) > 4, ]
extraction$n..parcelle
```

720 lignes pose problème

Lignes avec un chiffre décimal (voir avec Rabia)

```{r}
ind <- grep ("\\.",extraction$n..parcelle )
extraction$n..parcelle [ind]
write.csv(extraction, "../data/exportPbPointParcelle.csv", fileEncoding =  "UTF-8")
```

45 lignes à traiter plus tard

On utilise les variables texte et texteCol


## Extraction des premiers éléments uniquement


Cela permet de pouvoir faire des cartographies.

### Référence cadastrale


```{r}
registreF$section1 <- substring(registreF$section.cadastrale,1,2)
registreF$n..parcelle1 <- substring(registreF$n..parcelle, 1,3)
#Elimination de tous les caractères parasites sur les parcelles
registreF$n..parcelle1 <- gsub(",|\\.| |\n|_|-|N","",registreF$n..parcelle1 )
registreF$cadastre <- paste0(registreF$section1, registreF$n..parcelle1)
```


### Jointure cadastre / registreF


```{r}
# les clés
cadastre$section <- substring (cadastre$geo_parcelle,10,11 )
cadastre$section <- gsub("0","",cadastre$section)
cadastre$parcelle <- substring (cadastre$geo_parcelle,13,15 )
cadastre$parcelle <- gsub("0","",cadastre$parcelle)
cadastre$ref <- paste0(cadastre$section, cadastre$parcelle)
cadastre$ref
adsCarto1 <- merge(cadastre, registreF, all.y = F, by.x = "ref", by.y = "cadastre")
write_sf(adsCarto1, "../data/ads.gpkg", "adsCarto", delete_layer = T)
```


### Contrôle

```{r}
# contrôle 900 elts non repris (5263 - 4391), 1/5 quand même...
# elements présents dans le registre mais pas dans le cadastre
setdiff(registreF$cadastre,adsCarto1$cadastre)
ind <- grep( "AL38",cadastre$ref,value = F)
cadastre[ind,]
registreF [registreF$référence == "AL38",]
ind <- grep("AL38",registreF$cadastre)
registreF [registreF$cadastre == "AL38",]
registreF[ind,]
```

TODO pb

## Suprression des espaces

La colonne n..parcelle comporte des numéros séparés par pl espace
Idem pour la colonne section cadastrale

Démarche pour la section

- remplacement de tous les caractères de séparation par un caractère unique (l'espace)
- remplacement de 1er espace par un ;
- suppression de tous les espaces restants


Cela ne fonctionne que si 2 éléments... ce qui est le cas pour les sections.

```{r}
texte <- extraction
texteCol <- extraction$section.cadastrale
ch <- "','&'et'&/'\n'&'à'&'/'&'-'"
chTot <- paste0("[",ch,"]")
testSection <- gsub(chTot, " ", registre$section.cadastrale)
testSection <- sub(" ",";",registre$section.cadastrale)
testSection <- gsub(" ","", testSection)
testParcelle <- sub(" ", ";", registre$n..parcelle)
testParcelle <- gsub (" ", "", testParcelle)
export <- cbind(testSection, testParcelle,  registre$section.cadastrale, registre$n..parcelle)
write.csv(export, "../data/export.csv", fileEncoding = "UTF-8")
```

tests divers

Comparaison nb cas avant et après

```{r}
nbDeb <- length(grep(chTot, registre$section.cadastrale))
nbFin <- length(grep(chTot, testSection))
```

C'est bizarre, il faut passer plusieurs fois gsub ? Pb du t qui disparaît


plusieurs shémas à rassembler en un. / , et espace deviennent uniquement /
puis on adjoint la section à chaque numparcelle

```{r}

strsplit(test, " |/|,\.")
```


