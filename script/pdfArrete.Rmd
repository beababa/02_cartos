---
title: "OCR arrêté"
author: "B. Maranget"
date: "20/07/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

Ouverture fichier pdf arrêté lecture numéro d'arrêté

# Sources

https://www.datanovia.com/en/blog/easy-image-processing-in-r-using-the-magick-package/

https://pyimagesearch.com/2020/08/03/tesseract-ocr-for-non-english-languages/


# Import

```{r}
library(pdftools)
library(tidyverse)
library(tesseract)
library(magick)
library(tictoc)
```
Ne pas jouer


```{r}
library(sf)
library(mapsf)
```


## Lecture de tous les fichiers .pdf et  conversion en image

```{r, eval = FALSE}
path <- dir (path = "C:/ARRETES", pattern = "*.pdf", full.names = TRUE)
for (i in 1:length(path)){
  pngfile <- pdftools::pdf_convert(path[i], dpi = 100)
}
```


## Reconnaissance de l'écriture (ocr) et mise en liste

tic toc sont là pour mesurer le temps

```{r, eval = FALSE}
#  Uniquement les premières pages
path <- dir ( pattern = "*_1.png",full.names = TRUE)
equiv <- substr(path, 12,25)
images <- map(path, magick::image_read)
tic()
text_list <- map(images, ocr)
toc()
stext <- str_split(text_list, "\n")
```


## Extraction des titres des arrêtés


après A2021


```{r}
# 232 textes 2 exemples
images[91]
(extr <- stext [[91]])
# fonctions pour chercher chaine
chercherType <- function (chaine) {
  lg_type <- grep("A2021",chaine, ignore.case = TRUE,value = FALSE)
}
vLoc <- c("rue","allée","villa","chemin","avenue","place","voies","Esplanade")
chercherLoc <- function (chaine) {
  lg_loc <- grep("rue|allée|villa|chemin|avenue|place|voies|Esplanade",chaine, ignore.case = TRUE,value = FALSE)
}
premiereOccurence <- function(liste) {
  vecteur <-  NULL
  i <- 1
  for (i in 1:length(liste)) {
    tmp <- liste [[i]][1]
    vecteur <- c(vecteur, tmp)
  }
  return(vecteur)
}
liste <- lapply(stext, chercherType)
liste
# plusieurs occurences car réf VU
lgType <- premiereOccurence(liste)
# filtrage uniquement sur les vrais arrêtés
ok <- which(!is.na(lgType))
stextSel <- stext [c(ok)]
# 194 vrais arrêtés
# test pour vérifier
liste <- lapply(stextSel, chercherType)
liste
lgType <- premiereOccurence(liste)
length(which(is.na(lgType)))==0
# pas de NA dans la liste des arrêtes
# on cherche les adresses
liste <- lapply(stextSel, chercherLoc)
liste
lgLoc <- premiereOccurence(liste)
pb <- which(is.na(lgLoc))
# pb empty c'est pas de pb
stextSel[c(pb)]
loc <- NULL
i <- 1
for (i in 1:length(stextSel)){
  tmp <- stextSel [[i]][lgLoc[i]]
  loc <- c(loc, tmp)
}
head(loc)
# sauvegarde du résulat
write.csv2(loc, "lieux.csv")
```

## Extraction de la localisation


```{r}
loc <- read.csv2("../data/lieux.csv", fileEncoding = "CP1252")
str(loc)
grep("Villa", loc [1], value = TRUE)
```





# Géocodage

Nettoyage


```{r}
head(loc)
categ <- c("Interdiction", "momentanée", "momentanée","circulation", "Modification","Réglementation", "Autorisation","stationnement")
categ2 <-paste(categ, collapse =  " | ")
codeCateg <- c("STAT", "CIRC")
loc2 <-gsub (categ2," ", loc$x, ignore.case = TRUE)
loc2
loc3 <- gsub(categ2, " ", loc2)
loc3
res <- NULL
nettoyage <- function(fin){
  data <- gsub (categ[fin]," ", loc$x, ignore.case = TRUE)
  print(fin)
  if (fin!=0){
     data2 <- nettoyage(mot [fin-1], data)
     return(data2)
  }
  else {
     return(data2)
  }
  
 
}
res <- nettoyage 
nettoyage(nettoyage(nettoyage(loc$x)))
```

les rues

```{r}
momentanée 
rue <- read.csv("../data/indexRues.csv")
rue
chemin <- "D:/03_SIG/03_03_Data/"
rue <- st_read(paste0(chemin, "03_SOCLE/rue2023.gpkg"))
rue <- paste(rue$NOM, collapse = "|")
loc3_df <- as.data.frame(loc3)
ind <- grep(rue [1], loc3_df$loc3)
```

On recherche le nom de la rue 


https://ichi.pro/fr/guide-rapide-de-la-reconnaissance-d-entites-et-du-geocodage-avec-r-211832443971733




```{r}
library(tidygeocoder)
result_tidygeocoder=tidygeocoder::geocode(adresse_df,
                                          adresse,
                                          method="osm")
result_tidygeocoder
```

```{r}
adresse <- paste0(loc3, ", 93140, Bondy")
adresse_df <- as.data.frame(adresse)
adresse_df
locgeo <- geocode(adresse, limit = 1)
```


Les résultats ne sont pas bons.7/ 194...

Or, j'ai quand même une table d'équivalence.

Il s'agit de repérer les motifs RUE et d'afficher dans le tableau de départ (loc3)
une colonne equiv qui va permettre de faire le lien

```{r}
i <- 375
rue$NOM [i]
rue$NOM
loc <- loc3
loc3$correspondance <- NA
trouverCorrespondance <- function(i){
  res <- grep(rue$NOM [i], loc3, ignore.case = T)
  }
res <- sapply(1:387, trouverCorrespondance)
res
loc3$correspondance
for (i in c(1:387)){
  tmp <- res [[i]]
  loc3$correspondance
}
ind <- which(sapply(res, length)!=0)
ind
loc3 [ind]

```


