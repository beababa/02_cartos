---
title: "OCR arrêté"
author: "B. Maranget"
date: "20/07/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


# Objet

Ouverture fichier pdf arrêté lecture lieu et date de l'arrêté

# Sources

https://www.datanovia.com/en/blog/easy-image-processing-in-r-using-the-magick-package/

https://pyimagesearch.com/2020/08/03/tesseract-ocr-for-non-english-languages/


# Import

```{r}
library(pdftools)
library(tidyverse)
library(tesseract)
library(magick)
library(tictoc)
```



```{r}
library(sf)
library(mapsf)
```




# Chemins

```{r}
Sys.getenv("HOME")
chemin <- paste0(Sys.getenv("HOME"),"/03_SIG/03_03_Data/03_SOCLE/")
```



## Lecture de tous les fichiers .pdf et  conversion en image

```{r, eval = FALSE}
path <- dir (path = "C:/ARRETES", pattern = "*.pdf", full.names = TRUE)
for (i in 1:length(path)){
  pngfile <- pdftools::pdf_convert(path[i], dpi = 100)
}
```


## Reconnaissance de l'écriture (ocr) et mise en liste

tic toc sont là pour mesurer le temps

```{r, eval = FALSE}
#  Uniquement les premières pages
path <- dir ( pattern = "*_1.png",full.names = TRUE)
equiv <- substr(path, 12,25)
images <- map(path, magick::image_read)
tic()
text_list <- map(images, ocr)
toc()
stext <- str_split(text_list, "\n")
stext [[1]] [1:18]
stext [[2]][1:25]
stext [[3]][1:18]
```


## Extraction des lieux et dates des arrêtés

### Extraction des chaînes

après A2022 titre de l'arrêté
on extrait les termes avec les rues etc... (1er filtre)
puis on prend la 1e occurence



```{r}
# 232 textes 2 exemples
images[1]
(extr <- stext [[1]])
# fonctions pour chercher chaine
chaine <- stext [[1]]
chercherDate <- function (chaine) {
  ind <- grep("2022",chaine, ignore.case = TRUE,value = FALSE)
  # on supprime la 1e occurence, car c'est forcemment le titre
  ind <- ind [-1]
  res <- chaine[ind] 
}
vLoc <- c("rue","allée","villa","chemin","avenue","place","voies","Esplanade")
chercherLoc <- function (chaine) {
  lg_loc <- grep("rue|allée|villa|chemin|avenue|place|voies|Esplanade",chaine, ignore.case = TRUE,value = FALSE)
  res <- chaine[lg_loc]
}
premiereOccurence <- function(liste) {
  vecteur <-  NULL
  i <- 1
  for (i in 1:length(liste)) {
    tmp <- liste [[i]][1]
    vecteur <- c(vecteur, tmp)
  }
  return(vecteur)
}
liste <- lapply(stext, chercherLoc)
lieu <- premiereOccurence(liste)
liste <- lapply(stext, chercherDate)
date <- premiereOccurence(liste)
# plusieurs occurences car liste = # plusieurs occurences car réf VU
lieu
date
```



### Extraction des termes


```{r}
lieu <- as.data.frame(lieu)
# pour le nom
lieu$NOM <- NA
# pour la nature
lieu$EXTR <-  NA
```





#### Ñom rues

On récupère la liste des rues et on cherche toutes les rues correspondantes.



```{r}
rues <- st_read(paste0(chemin, "socle2024.gpkg"),"rues")
nb <- length(rues$NOM)
# Utilisation d'une fonction plutôt qu'une boucle
# le mot clé est dans la table des rues, pas dans l'extraction de l'arrêté
trouverCorrespondance <- function(i){
  res <- grep(rues$NOM [i], lieu, ignore.case = T)
  }
res <- sapply(c(1:nb), trouverCorrespondance)
# filtre sur les item de la liste ayant une correspondance (différent de zéro)
ind <- which(sapply(res, length)!=0)
ref <- rues [ind,]
ref
```


#### Jointure

Récupération des clés

```{r}

for (r in ref$NOM){
  print(r)
  ind <- grep(r, lieu$lieu, ignore.case = T )
  print(ind)
  lieu$NOM [ind] <- r
}
jointure <- merge(ref, lieu, by = "NOM")
table(jointure$NOM)
```

Noms à préciser


### Nature

on repère le motif correspondant à une clé, et on joint pour récupérer le motif de reférence

```{r}
# table d'équivalence constituée peu à peu à partir de jointure
NATURE <- c("AV", "R","CH")
EXTR <- c("Avenue","rue", "Chemin")
equiv <- data.frame(NATURE,EXTR)
for (e in equiv$EXTR){
  print(e)
  ind <- grep(e, jointure$lieu, ignore.case = T )
  print(ind)
  jointure$EXTR [ind] <- e
}
lieu
equiv
jointure <- merge(lieu,equiv, by=c("EXTR"))
jointure
```






Cas particuliers hors corpus d'exemple

```{r}
# filtrage uniquement sur les vrais arrêtés
ok <- which(!is.na(lgType))
stextSel <- stext [c(ok)]
# 194 vrais arrêtés
# test pour vérifier
liste <- lapply(stextSel, chercherType)
liste
lgType <- premiereOccurence(liste)
length(which(is.na(lgType)))==0
# pas de NA dans la liste des arrêtes
# on cherche les adresses
liste <- lapply(stextSel, chercherLoc)
liste
lgLoc <- premiereOccurence(liste)
pb <- which(is.na(lgLoc))
# pb empty c'est pas de pb
stextSel[c(pb)]
```


```{r}
loc <- NULL
i <- 1
for (i in 1:length(stextSel)){
  tmp <- stextSel [[i]][ind[i]]
  loc <- c(loc, tmp)
}
head(loc)
# sauvegarde du résulat
write.csv2(loc, "lieux.csv")
```

